1. Необязательное задание: можно посмотреть целый фильм в консоли telnet towel.blinkenlights.nl :)

2. Узнайте о том, сколько действительно независимых (не пересекающихся) каналов есть в разделяемой среде WiFi при работе на 2.4 ГГц. Стандарты с полосой 5 ГГц более актуальны, но регламенты на 5 ГГц существенно различаются в разных странах, а так же не раз обновлялись. В качестве дополнительного вопроса вне зачета, попробуйте найти актуальный ответ и на этот вопрос.

2.4GHz
Всего 14 каналов, 
С учетом того, что в стандарте предуссмотрена разная ширина канала : 10, 20, 22, 40, 80 и 160 МГц, основные 20 и 40 используются
при ширне канала = 40 МГц, всего 3 непересекающихся канала: 1,6,11.
каналы шириной 80 и 160 МГц в диапазон 2.4 ГГц, не имеют не пересекающихся каналов.

5GHz
В разных странах разрешенные разные 
По разрешенным каналам в РФ:
20Мгц - 17 каналов
40Мгц - 8
80Мгц - 4
160Мгц -1


3. Адрес канального уровня – MAC адрес – это 6 байт, первые 3 из которых называются OUI – Organizationally Unique Identifier или уникальный идентификатор организации. Какому производителю принадлежит MAC 38:f9:d3:55:55:79?

Производитель: компания Apple

10:19:37 gmi@upc(0):~/mac_check$ ./oui.sh 38:f9:d3:55:55:79
Для MAC 38:f9:d3:55:55:79 найдена следующая информация:
38F9D3     (base 16)		Apple, Inc.
				1 Infinite Loop
				Cupertino  CA  95014
				US

4. Каким будет payload TCP сегмента, если Ethernet MTU задан в 9001 байт, размер заголовков IPv4 – 20 байт, а TCP – 32 байта?

TCP Segment = 8981 (MTU - Ethernet Header)

5. Может ли во флагах TCP одновременно быть установлены флаги SYN и FIN при штатном режиме работы сети? Почему да или нет?

Не могут, так как SYN - начинает соединение, а FIN завершает, 
Одним пакетом нельзя одновременно и открыть и закрыть сессию.

6 . ss -ula sport = :53 на хосте имеет следующий вывод:

State           Recv-Q          Send-Q                   Local Address:Port                     Peer Address:Port          Process
UNCONN          0               0                        127.0.0.53%lo:domain                        0.0.0.0:*
Почему в State присутствует только UNCONN, и может ли там присутствовать, например, TIME-WAIT?

UNCONN - соединение не установлено,
Time-wait - это состояние когда сокет отправил подтверждение о получении завершения соединение и ждет, что сообщение доставлено.
Так как -u сообщает нам про вывод UDP порта, а он не использует предварительные пакеты для соеинения и синхронизации, 
следовательно и для разрыва соединения ему не нужно ждать завершения сессии.

7. Обладая знаниями о том, как штатным образом завершается соединение (FIN от инициатора, FIN-ACK от ответчика, ACK от инициатора), опишите в каких состояниях будет находиться TCP соединение в каждый момент времени на клиенте и на сервере при завершении. Схема переходов состояния соединения вам в этом поможет.

                    Client           Server 
                 ESTABLESHED      ESTABLESHED
1. >> FIN        FIN WAIT 1   >   CLOSE WAIT
2. << FIN-ACC    FIN WAIT 2   >   CLOSE WAIT 
3. >> ACK        TIME WAIT    <   LAST ACK
                 CLOSED       >   CLOSED


8 . TCP порт – 16 битное число. Предположим, 2 находящихся в одной сети хоста устанавливают между собой соединения. Каким будет теоретическое максимальное число соединений, ограниченное только лишь параметрами L4, которое параллельно может установить клиент с одного IP адреса к серверу с одним IP адресом? Сколько соединений сможет обслужить сервер от одного клиента? А если клиентов больше одного?

Максимальное число портов  = 65535 (макс значение в 16 бит)
В теории максимальное число соединений от одного клиента для сервера может быть  = 65535 
В теории может быть открыт 1 порт на каждого клиента и слушать 65535 соединений клиента
уникальным должна быть пара SERVER_IP:PORT - Client_IP:PORT 
в таком варианте это 65535 клиентов, и с каждым 65535 соединений, но боюсь тут может не хватить дескрипторов в ОС и других ресурсов

9. Может ли сложиться ситуация, при которой большое число соединений TCP на хосте находятся в состоянии TIME-WAIT? Если да, то является ли она хорошей или плохой? Подкрепите свой ответ пояснением той или иной оценки.

Да может, при частом соединении и отсоединении.
При частом соединении и отключении создается соединение и соотвествено выделяется каждый раз порт
и предыдущая сессия какое-то время остаётся незакрытой, новая сессия может начаться раньше чем будет закрыта предудущая 
и при большом числе соединений такое может вызвать накопление соединение и расход соответсвующих ресурсов.
А если все соеднения идут к одной службе, то может так же возникнуть ситуация когда кончаться порты. 


10. Чем особенно плоха фрагментация UDP относительно фрагментации TCP?

Если один из фрагментов не дойдет, то необходимо перепослать весь пакет снова, 
но в UDP нет контроля ошибок, и как следствие информация не дойдет.


11. Если бы вы строили систему удаленного сбора логов, то есть систему, в которой несколько хостов отправяют на центральный узел генерируемые приложениями логи (предположим, что логи – текстовая информация), какой протокол транспортного уровня вы выбрали бы и почему? Проверьте ваше предположение самостоятельно, узнав о стандартном протоколе syslog.

Я бы использовал TCP, так как есть механизм гарантированной доставки пакетов, чего нет в UDP, а для логов это самое важное.
Например logstash использует TCP (http)

Первоначально syslog использовал UDP, но в следующей редакции использовался TCP.

12. Сколько портов TCP находится в состоянии прослушивания на вашей виртуальной машине с Ubuntu, и каким процессам они принадлежат?
 
 vagrant@netology1:~$ sudo ss  state listening -t -p
Recv-Q      Send-Q           Local Address:Port             Peer Address:Port     Process                                                       
0           4096                   0.0.0.0:sunrpc                0.0.0.0:*         users:(("rpcbind",pid=545,fd=4),("systemd",pid=1,fd=74))     
0           511                    0.0.0.0:http                  0.0.0.0:*         users:(("nginx",pid=8914,fd=6),("nginx",pid=8913,fd=6))      
0           4096             127.0.0.53%lo:domain                0.0.0.0:*         users:(("systemd-resolve",pid=546,fd=13))                    
0           128                    0.0.0.0:ssh                   0.0.0.0:*         users:(("sshd",pid=973,fd=3))                                
0           4096                      [::]:sunrpc                   [::]:*         users:(("rpcbind",pid=545,fd=6),("systemd",pid=1,fd=76))     
0           511                       [::]:http                     [::]:*         users:(("nginx",pid=8914,fd=7),("nginx",pid=8913,fd=7))      
0           128                       [::]:ssh                      [::]:*         users:(("sshd",pid=973,fd=4))                                

Прослушиваемых портов = 5 IPv4 + 8IPv6
Процессы соответсвенно: systemd,sshd,nginx
 
13. Какой ключ нужно добавить в tcpdump, чтобы он начал выводить не только заголовки, но и содержимое фреймов в текстовом виде? А в текстовом и шестнадцатиричном?

tcpdump -A - выведет содержание в ASCII (в тексте)

vagrant@netology1:~$ sudo tcpdump -A -c 1
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
15:02:36.478937 IP netology1.ssh > _gateway.60694: Flags [P.], seq 4239266463:4239266499, ack 25264635, win 62780, length 36
E..L..@.@..m
...
...............P..<.O..f....
....Zi&:.........Q.....>.`..5s
1 packet captured
36 packets received by filter
3 packets dropped by kernel

tcpdump -x - выведет соедржимое пакетов в hex

vagrant@netology1:~$ sudo tcpdump -x -c 1
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
15:02:51.766283 IP netology1.ssh > _gateway.60694: Flags [P.], seq 4239268351:4239268387, ack 25265535, win 62780, length 36
	0x0000:  4510 004c 9850 4000 4006 8a3b 0a00 020f
	0x0010:  0a00 0202 0016 ed16 fcae 19ff 0181 857f
	0x0020:  5018 f53c 184f 0000 2a9c 92a8 21ac 4618
	0x0030:  4462 299f e297 ed3f 8572 c987 fd6c cbeb
	0x0040:  a8be 0a65 54a2 0dce f927 e3f6
1 packet captured
50 packets received by filter
17 packets dropped by kernel

tcpdump -XX - выведет соедржимое пакетов в hex

14. Попробуйте собрать дамп трафика с помощью tcpdump на основном интерфейсе вашей виртуальной машины и посмотреть его через tshark или Wireshark (можно ограничить число пакетов -c 100). Встретились ли вам какие-то установленные флаги Internet Protocol (не флаги TCP, а флаги IP)? Узнайте, какие флаги бывают. Как на самом деле называется стандарт Ethernet, фреймы которого попали в ваш дамп? Можно ли где-то в дампе увидеть OUI?

Собирал дамп на хостовой машине(так же Ubuntu 20.4), 

Встретил флаги IP: Don't fragment(второй бит 0 1 0), 
Всего 3 бита:
    0 - зарезервиравано, всегда 0,
    1 - указывает на фрагментирование , 0 - разрешена фрагментация, 1 - нет
    2 - указывает на конец фрагментированных пакетов , 1 - не последний фрагмент (актуально для 1го бита = 0)
Ethernet называется Ethernet II

В дампе OUI можно увидеть в заголовке Ethernet пакета в виде короткого имени и ID (часть MACа)
например: Destination: HonHaiPr_8c:ed:c5 (c0:38:96:8c:ed:c5)